<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI助手 - ReSpider Mod Wiki</title>
    <link rel="icon" href="ico/title-logo.ico">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/wiki-ai.css">
</head>
<body>
    <div class="wiki-bg">
        <div class="wiki-header">
            <div class="wiki-header-title">
                <a href="index.html">ReSpider Mod</a>
            </div>
            <div class="wiki-header-logo">
                <img src="img/wiki-logo.png" alt="logo" width="128px">
            </div>
        </div>
        
        <div class="wiki-nav"> 
            <a href="index.html">首页</a>
            <a href="character.html">人物</a>
            <a href="skill.html">技能</a>
            <a href="wiki-ai.html" class="active">AI助手</a>
        </div>
        
        <div class="wiki-content">
            <div id="ai-assistant">
                <!-- 聊天消息区域 -->
                <div class="chat-messages" ref="messagesContainer">
                    <!-- 遍历 messages 数组，动态生成消息 -->
                    <div v-for="(msg, index) in messages" :key="msg.id" :class="['message', msg.role === 'user' ? 'user-message' : 'ai-message']">
                        <div class="message-header">
                            <strong>{{ msg.role === 'user' ? '你' : 'Spider AI' }}</strong>
                            <span class="time">{{ formatTime(msg.timestamp) }}</span>
                        </div>
                        <div class="message-content">
                            <!-- 使用 v-html 或 {{ }} 渲染内容，这里用文本渲染确保安全 -->
                            {{ msg.content }}
                        </div>
                    </div>
                </div>
                
                <!-- 输入区域 -->
                <div class="input-area">
                    <textarea 
                        v-model="userInput" 
                        placeholder="输入您的问题..."
                        @keydown.enter.prevent="sendMessage"
                        rows="3"
                    ></textarea>
                    <button @click="sendMessage" :disabled="isLoading">
                        {{ isLoading ? '思考中...' : '发送' }}
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
    import { createApp } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";


    createApp({
        data() {
            return {
                userInput: '',
                messages: [],
                isLoading: false,
                currentStreamingMessage: '',
                isStreaming: false
            }
        },
        mounted() {
            // 添加欢迎消息
            this.messages.push({
                id: 0,
                role: 'assistant',
                content: '你好！我是ReSpider Wiki的AI助手，有什么可以帮助您的吗？',
                timestamp: new Date()
            });
        },
        methods: {
            formatTime(timestamp) {
                if (!timestamp) return '';
                const date = new Date(timestamp);
                // 格式化为 时:分:秒
                return date.toLocaleTimeString('zh-CN', { hour12: false });
            },
            async sendMessage() {
                if (!this.userInput.trim() || this.isLoading) return;
                
                // 添加用户消息
                const userMessage = this.userInput.trim();
                this.messages.push({
                    id: Date.now(),
                    role: 'user',
                    content: userMessage,
                    timestamp: new Date()
                });
                
                // 清空输入框
                this.userInput = '';
                
                // 开始加载
                this.isLoading = true;
                
                try {
                    await this.sendNormalRequest(userMessage);
                } catch (error) {
                    console.error('请求失败:', error);
                    this.messages.push({
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: `抱歉，出错了：${error.message}`,
                        timestamp: new Date()
                    });
                } finally {
                    this.isLoading = false;
                    this.isStreaming = false;
                    this.currentStreamingMessage = '';
                }
            },
            
            
            async sendNormalRequest(userMessage) {
                // 为AI的回复预先创建一个“空”消息卡片，用于后续追加内容
                const aiMessageIndex = this.messages.length;
                this.messages.push({
                    id: Date.now(), // 唯一ID
                    role: 'assistant',
                    content: '', // 内容初始为空，后续逐步追加
                    timestamp: new Date(),
                    isStreaming: true // 可选标记，用于UI显示加载状态
                });

                try {
                    const proxyUrl = 'https://respider-wiki.vercel.app/api/chat';
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            messages: this.messages.slice(0, -1).map(msg => ({ // 注意：不包含刚创建的空白AI消息
                                role: msg.role,
                                content: msg.content
                            })),
                            stream: true // 启用流
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API请求失败：${response.status} - ${errorText}`);
                    }

                    // 以下为处理流式响应的核心逻辑
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let accumulatedText = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break; // 流结束

                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6); // 去掉 'data: ' 前缀
                                if (data === '[DONE]') continue; // 流结束信号

                                try {
                                    const parsed = JSON.parse(data);
                                    const contentDelta = parsed.choices[0]?.delta?.content || '';
                                    if (contentDelta) {
                                        accumulatedText += contentDelta;
                                        // 关键：实时更新第 aiMessageIndex 条消息的内容
                                        this.messages[aiMessageIndex].content = accumulatedText;
                                    }
                                } catch (e) {
                                    console.warn('解析流数据失败:', e, '原始数据:', data);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('流式请求过程中发生错误:', error);
                    // 如果出错，更新那条空白AI消息为错误信息
                    this.messages[aiMessageIndex].content = `抱歉，请求AI时出现错误：${error.message}`;
                } finally {
                    // 流结束，无论成功失败，移除流式标记
                    if (this.messages[aiMessageIndex]) {
                        this.messages[aiMessageIndex].isStreaming = false;
                        // 确保最终时间戳是完整的
                        this.messages[aiMessageIndex].timestamp = new Date();
                    }
                    this.isLoading = false;
                }
            },
            scrollToBottom() {
                this.$nextTick(() => {
                    const container = this.$refs.messagesContainer;
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                });
            }
        }, 
        watch: {
            // 当消息更新时自动滚动
            messages: {
                handler() {
                    this.scrollToBottom();
                },
                deep: true
            }
        }
    }).mount("#ai-assistant");
    </script>
</body>
</html>